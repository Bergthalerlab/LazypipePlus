#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long qw(GetOptions);

# 
# Prints stats for an assembly
my $usage= "\nUSAGE: $0 --format|f format --reads reads.fq --reads_flt reads.flt.fq --reads_hgflt reads.hgflt.fq ".
           "            --cont contigs.fa --idx contigs.idxstats --orfs ORFs.fa\n\n".
	   "reads       [file] : fastq file containing the original reads. Can be gziped.\n".
	   "reads_flt   [file] : fastq file containing trimmed reads.\n".
	   "reads_hgflt [file] : fastq file containing hostgenome filtered reads.\n".
	   "cont        [file] : fasta file containing contigs.\n".
	   "idx         [file] : text file generated by the samtools idxstats for bam file mapping reads to contigs\n".
	   "orfs        [file] : fasta file containing nt ORF sequences\n".
	   "\n".
	   "format [str]  : col|row[,names,%], default \'row,names\'\n".
	   "      col     : stats printed in a single column\n".
	   "      row     : stats printed in a single row\n".
	   "      names   : in col format will print metric names in the first column and values in the second\n".
	   "                in row format will print header row with metric names\n".
	   "      %       : print stats in percents\n".
	   "\n".
	   "printed statistics:\n".
	   "reads         : number of read pairs in unfiltered library\n".
	   "reads.flt     : number of read pairs in filtered library\n".
	   "reads.hgflt   : number of read pairs in host-genome filtered library\n".
	   "reads.contigs : number of read pairs mapped to contigs\n".
	   "reads.orfs    : number of read pairs mapped to contigs with orfs\n".
	   "contigs       : number of contigs\n".
	   "orfs          : number of genes\n".
	   "contigs.orfs  : number of contigs with ORFs\n".
	   "\n";
	   
my $format				= "row,names";
my $reads_fa 			= !1;
my $reads_flt_fa		= !1;
my $reads_hgflt_fa		= !1;
my $contigs_fa			= !1;
my $orfs_fa 			= !1;
my $idxstats			= !1;
GetOptions(	'format|f=s' 	=> \$format,
		'reads=s'			=> \$reads_fa,
		'reads_flt=s'		=> \$reads_flt_fa,
		'reads_hgflt=s'		=> \$reads_hgflt_fa,
		'contigs|cont=s'	=> \$contigs_fa,
		'orfs=s'			=> \$orfs_fa,
		'idxstats|idx=s'	=> \$idxstats) or die $usage;

# CHECK INPUT
if( !($format =~m/(row|col)/ig) ){
	print STDERR "\ninvalid format: $format\n";
	die $usage;
}
if( !$reads_flt_fa || !$contigs_fa || !$orfs_fa || !$idxstats){
	print STDERR "\nmissing arguments\n";
	die $usage;
}
if( !$reads_fa ){
	$reads_fa 		= $reads_flt_fa;
}
if( !$reads_hgflt_fa){
	$reads_hgflt_fa = $reads_flt_fa;
}

if( !(-e $reads_fa) )   		{ die "$0: missing file: $reads_fa\n";}
if( !(-e $reads_flt_fa) )   	{ die "$0: missing file: $reads_flt_fa\n";}
if( !(-e $reads_hgflt_fa) )   	{ die "$0: missing file: $reads_hgflt_fa\n";}
if( !(-e $contigs_fa) )			{ die "$0: missing file: $contigs_fa\n";}
if( !(-e $orfs_fa) )  			{ die "$0: missing file: $orfs_fa\n";}
if( !(-e $idxstats) )			{ die "$0: missing file: $idxstats";}


# printing headers
my @headers;
push(@headers,('reads','reads.flt','reads.hgflt','reads.contigs','reads.orfs','contigs','orfs','contigs.orfs'));
my %stats_hash;
foreach my $h(@headers){ $stats_hash{$h} = 0;}

$stats_hash{'reads'} 		= ($reads_fa =~ m/\.gz$/ )? ((`gunzip -c $reads_fa | wc -l`)/4) : (`cat $reads_fa | wc -l`)/4;
$stats_hash{'reads.flt'} 	= (`cat $reads_flt_fa | wc -l`)/4;
$stats_hash{'reads.hgflt'} 	= (`cat $reads_hgflt_fa | wc -l`)/4;

# contigs
my %contigs 	= %{readfasta($contigs_fa)};
foreach my $id(keys %contigs){
	$id =~ m/^\w+[=_]([A-Za-z0-9\.]+)_/;
	$contigs{$1} = $contigs{$id};
	delete( $contigs{$id} );
}
$stats_hash{'contigs'}= scalar keys %contigs;


# ORFs + contigs.orfs
my %orfs			= %{readfasta($orfs_fa)};
$stats_hash{'orfs'} = scalar keys %orfs;

my %contig_orfnum	= ();	# contig_id > orfnum
foreach my $seqid( keys %orfs){
	my $contid	= $seqid;
	$contid 	=~ m/^\w+[=_]([A-Za-z0-9\.]+)_/;
	$contid 	= $1;
	if( defined($contig_orfnum{$contid}) ){
		$contig_orfnum{$contid}++;
	}
	else{
		$contig_orfnum{$contid} = 1;
	}
}
$stats_hash{'contigs.orfs'} = scalar keys %contig_orfnum;

# reads.contigs
open(IN, "<$idxstats") or die "failed to open: $idxstats\n";
my %cont_readn;
while(my $l=<IN>){
	chomp($l);
	my @sp= split(/\t/,$l,-1);
	if($sp[0] =~ m/^\w+[=_]([A-Za-z0-9\.]+)/gi){
		my $cont_id= $1;
		#print "contig:\"$cont_id\"\n";exit(1);
		$cont_readn{$cont_id}= $sp[2]; # col3: mapped reads
		$stats_hash{'reads.contigs'} += $sp[2];
	}
}close(IN);

# reads.orfs
foreach my $id( keys %contig_orfnum ){
	 
	if( defined($cont_readn{$id}) ){
		$stats_hash{'reads.orfs'} += $cont_readn{$id};
	}
	else{
		print STDERR "WARNING: contig=$id not found in $idxstats\n";
	}
}


if( ($format =~ m/(\%)/) ){
	$stats_hash{'reads.flt'} 		= $stats_hash{'reads.flt'} / $stats_hash{'reads'} *100;
	$stats_hash{'reads.hgflt'}		= $stats_hash{'reads.hgflt'} / $stats_hash{'reads'} *100;
	$stats_hash{'reads.contigs'}	= $stats_hash{'reads.contigs'} / $stats_hash{'reads'} *100;
	$stats_hash{'reads.orfs'}		= $stats_hash{'reads.orfs'} / $stats_hash{'reads'} *100;
	$stats_hash{'reads'}	 		= 100;
	$stats_hash{'contigs.orfs'}		= $stats_hash{'contigs.orfs'} / $stats_hash{'contigs'} *100;
}


# PRINTING
if( $format =~ m/(row)/i ){
	if( ($format =~ m/(names)/i) ){
		print "",join("\t",@headers),"\n";
	}
	
	print $stats_hash{$headers[0]};
	for(my $i=1; $i<scalar(@headers); $i++){
		print "\t",$stats_hash{$headers[$i]};
	}
	print "\n";
}
else{
	if( ($format =~ m/(names)/i) ){
		for(my $i=0; $i<scalar(@headers); $i++){
			print $headers[$i],"\t",$stats_hash{$headers[$i]},"\n";
		}
	}
	else{
		for(my $i=0; $i<scalar(@headers); $i++){
			print $stats_hash{$headers[$i]},"\n";
		}
	}
}

sub readfasta{
  	my $file		= shift(@_);
	my %sequence;
	my $header;
	my $temp_seq;
	 
	open (IN, "<$file") or die "couldn't open the file $file $!";
	
	while (<IN>){	
		chop;
		next if /^\s*$/; #skip empty line 
		if ($_ =~ s/^>//)  #when see head line
		{	
			$header= $_;
			if ($sequence{$header}){print colored("#CAUTION: SAME FASTA HAS BEEN READ MULTIPLE TIMES.\n#CAUTION: PLEASE CHECK FASTA SEQUENCE:$header\n","red")};
			if ($temp_seq) {$temp_seq=""} # If there is alreay sequence in temp_seq, empty the sequence file
			
		}
		else # when see the sequence line 
		{
		   s/\s+//g;
		   $temp_seq .= $_;
		   $sequence{$header}=$temp_seq; #update the contents
		}
	
	}
	
	return \%sequence;
}

